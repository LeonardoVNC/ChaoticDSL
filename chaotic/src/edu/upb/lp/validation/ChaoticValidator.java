/*
 * generated by Xtext 2.39.0
 */
package edu.upb.lp.validation;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

import edu.upb.lp.chaotic.BoolLiteral;
import edu.upb.lp.chaotic.CadenasLiteral;
import edu.upb.lp.chaotic.ChannelCall;
import edu.upb.lp.chaotic.ChannelOperation;
import edu.upb.lp.chaotic.ChannelSection;
import edu.upb.lp.chaotic.ChatSection;
import edu.upb.lp.chaotic.DataType;
import edu.upb.lp.chaotic.DecLiteral;
import edu.upb.lp.chaotic.Expression;
import edu.upb.lp.chaotic.IntLiteral;
import edu.upb.lp.chaotic.PairOperator;
import edu.upb.lp.chaotic.Program;
import edu.upb.lp.chaotic.SingleExpression;
import edu.upb.lp.chaotic.SingleOperator;
import edu.upb.lp.chaotic.SingleOperatorExpression;
import edu.upb.lp.chaotic.TempExpression;
import edu.upb.lp.chaotic.UserAsignation;
import edu.upb.lp.chaotic.UserDeclaration;
import edu.upb.lp.chaotic.UserSection;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class ChaoticValidator extends AbstractChaoticValidator {
	@Check
	public void checkUsersID(UserSection us) {
	    Set<String> users = new HashSet<>();
	    for (UserDeclaration userDeclaration : us.getUsers()) {
	        String currentID = userDeclaration.getName();
	        if (users.contains(currentID)) {
	            error("El nombre de usuario \"" + currentID + "\" ya está siento utilizado.", 
	            		userDeclaration, null);
	        } else {
	            users.add(currentID);
	        }
	    }
	}
	
	@Check
	public void checkChannelsID(ChannelSection cs) {
		Set<String> channels = new HashSet<>();
		for (ChannelOperation channelOperation : cs.getChannels()) {
			String currentChannelID = channelOperation.getName();
			if (channels.contains(currentChannelID)) {
				error("El nombre \"" + currentChannelID + "\" ya está siendo utilizado por otro canal.",
						channelOperation, null);
			} else {
				channels.add(currentChannelID);
			}
		}
	}
	
	@Check
	public void checkChannelUsage(Program p) {
		ChannelSection cns = p.getChannelSection();
		ChatSection cts = p.getExecution();
		Set<ChannelOperation> declaredChannels = new HashSet<>();
		for (ChannelOperation channelOperation : cns.getChannels()) {
			declaredChannels.add(channelOperation);
		}
		for (ChannelCall channelCall : cts.getBody().getChannels()) {
			ChannelOperation currentChannel = channelCall.getName();
			if (declaredChannels.contains(currentChannel)) {
				declaredChannels.remove(currentChannel);
			}
		}
		for (ChannelOperation notUsedChannel : declaredChannels) {
			warning("El canal #" + notUsedChannel.getName() + " no está siendo utilizado.",
					notUsedChannel, null);
		}
	}
	
	@Check
	public void checkChannelBody(ChannelOperation c) {
		int instruccions = c.getBody().getAsignations().size();
		instruccions += c.getBody().getPrints().size();
		instruccions += c.getBody().getIfs().size();
		instruccions += c.getBody().getWhiles().size();
		instruccions += c.getBody().getChannels().size();
		if (instruccions == 0) {
			warning("El cuerpo del canal #" + c.getName() + " está vació.", c, null);
		}
	}
	
	
	public DataType getDataTypeFromExp(Expression e) {
		//Mi caso base son los literales y los llamados a variables
		DataType firstType = null;
		if (e.getSingleExpr() != null) {
			firstType = getDataTypeFromSingleExpression(e.getSingleExpr());
		} else if (e.getUserRef() != null) {
			firstType = e.getUserRef().getUser().getType();
		} else if (e.getParenthesisExpr() != null) {
			firstType = getDataTypeFromExp(e.getParenthesisExpr().getExpression());
		} else if (e.getSingleOpExpr() != null) {
			firstType = getDataTypeFromSingleOperator(e.getSingleOpExpr().getOperator());
		} 
		if (e.getSecond() != null) {
			DataType expressionType = validateTemporalExpression(firstType, e.getSecond());
			//Operación inválida lanza un null
			if (expressionType == null) {
				return null; 
			} else {
				return expressionType;
			}
		} else {
			return firstType;	
		}
		
		
	}
	
	public DataType getDataTypeFromSingleExpression(SingleExpression se) {
		EObject literal = se.getLiteral();
		if (literal instanceof IntLiteral) {
			return DataType.ENTERO_TYPE;
		} else if (literal instanceof DecLiteral){
			return DataType.DEC_TYPE;
		} else if (literal instanceof BoolLiteral) {
			return DataType.BOOL_TYPE;
		} else if (literal instanceof CadenasLiteral) {
			return DataType.CADENAS_TYPE;
		} else {
			return null;
		}
	}
	
	public DataType getDataTypeFromSingleOperator(SingleOperator operator) {
		if (operator == SingleOperator.BOOL_NEGATION) {
			return DataType.BOOL_TYPE ;
		} else if (operator == SingleOperator.INT_NEGATIVE) {
			return DataType.ENTERO_TYPE;
		} else {
			return null;
		}
	}
	
	public DataType validateTemporalExpression(DataType firstType, TempExpression second) {
		PairOperator operator = second.getOperador();
		DataType secondType = getDataTypeFromExp(second.getSecondValue());
		DataType expressionType = null;
		
		if (operator == PairOperator.PLUS|| operator == PairOperator.LESS|| operator == PairOperator.MULT|| operator == PairOperator.DIV) {
			if (firstType == DataType.ENTERO_TYPE && secondType == DataType.ENTERO_TYPE) expressionType = DataType.ENTERO_TYPE;
			if (firstType == DataType.ENTERO_TYPE && secondType == DataType.DEC_TYPE ||
				firstType == DataType.DEC_TYPE && secondType == DataType.ENTERO_TYPE ||
				firstType == DataType.DEC_TYPE  && secondType == DataType.DEC_TYPE ) expressionType = DataType.DEC_TYPE;
		} else if (operator == PairOperator.AND && operator == PairOperator.OR) {
			if(firstType == DataType.BOOL_TYPE && secondType == DataType.BOOL_TYPE) expressionType = DataType.BOOL_TYPE;
		} else if (operator == PairOperator.GREATER|| operator == PairOperator.GREATER_P||
				operator == PairOperator.GREATER_EQ|| operator == PairOperator.GREATER_EQ_P ) {
			if (firstType == DataType.ENTERO_TYPE && secondType == DataType.ENTERO_TYPE ||
				firstType == DataType.ENTERO_TYPE && secondType == DataType.DEC_TYPE ||
				firstType == DataType.DEC_TYPE && secondType == DataType.ENTERO_TYPE ||
				firstType == DataType.DEC_TYPE  && secondType == DataType.DEC_TYPE ) expressionType = DataType.BOOL_TYPE;
		} else if (operator == PairOperator.EQUAL) {
			if (firstType == DataType.ENTERO_TYPE && secondType == DataType.ENTERO_TYPE ||
					firstType == DataType.ENTERO_TYPE && secondType == DataType.DEC_TYPE ||
					firstType == DataType.DEC_TYPE && secondType == DataType.ENTERO_TYPE ||
					firstType == DataType.DEC_TYPE  && secondType == DataType.DEC_TYPE ||
					firstType == DataType.BOOL_TYPE && secondType == DataType.BOOL_TYPE) expressionType = DataType.BOOL_TYPE;
		} else if (operator == PairOperator.CONCAT) {
			if (firstType == DataType.CADENAS_TYPE || secondType == DataType.CADENAS_TYPE) expressionType = DataType.CADENAS_TYPE;
		} else {
			return null;
		}
		
		if (second.getFollow() == null) {
			return expressionType;
		} else {
			return validateTemporalExpression(expressionType, second.getFollow());
		}
	}
	
	@Check
	public void checkAsignationDataType(UserAsignation ua) {
		DataType userType = ua.getUser().getType();
		Expression expr = ua.getValue();
		
		DataType exprType = getDataTypeFromExp(expr);
		if (exprType == null) {
			error ("Operaciones inválidas para estos tipos de datos.", ua, null);
		} else if (userType != exprType) {
			error("El usuario @" + ua.getUser().getName() + " forma parte de $" + userType.getName() + ", no de $" + exprType.getName(),
					ua, null);
		}
	}
	
	@Check
	public void checkSingleOperatorDataType(SingleOperatorExpression soe) {
		DataType expressionType = getDataTypeFromExp(soe.getExpression());
		SingleOperator operator = soe.getOperator();
		DataType operatorType = getDataTypeFromSingleOperator(operator);
		
		if (expressionType != operatorType) {
			error("La expresión pertenece a $" + expressionType + ", mientras que el operador pertence a $" + operatorType, soe, null);
		}
	}
}


