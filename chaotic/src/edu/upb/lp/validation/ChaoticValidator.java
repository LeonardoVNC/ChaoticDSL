/*
 * generated by Xtext 2.39.0
 */
package edu.upb.lp.validation;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

import edu.upb.lp.chaotic.BoolLiteral;
import edu.upb.lp.chaotic.CadenasLiteral;
import edu.upb.lp.chaotic.ChannelCall;
import edu.upb.lp.chaotic.ChannelOperation;
import edu.upb.lp.chaotic.ChannelSection;
import edu.upb.lp.chaotic.ChatSection;
import edu.upb.lp.chaotic.DataType;
import edu.upb.lp.chaotic.DecLiteral;
import edu.upb.lp.chaotic.Expression;
import edu.upb.lp.chaotic.FollowExpression;
import edu.upb.lp.chaotic.Instruction;
import edu.upb.lp.chaotic.IntLiteral;
import edu.upb.lp.chaotic.PairOperator;
import edu.upb.lp.chaotic.Program;
import edu.upb.lp.chaotic.SingleExpression;
import edu.upb.lp.chaotic.SingleOperator;
import edu.upb.lp.chaotic.SingleOperatorExpression;
import edu.upb.lp.chaotic.TempExpression;
import edu.upb.lp.chaotic.UserAsignation;
import edu.upb.lp.chaotic.UserDeclaration;
import edu.upb.lp.chaotic.UserSection;
import edu.upb.lp.chaotic.impl.ChannelCallImpl;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class ChaoticValidator extends AbstractChaoticValidator {
	Set<String> javaKeyWords = new HashSet<>(Arrays.asList(
			"String", "Integer", "Boolean", "abstract", "assert", "boolean", "break", "byte",
	        "case", "catch", "char", "class", "const", "continue", "default", "do", "double", "else", 
	        "enum", "extends", "final", "finally", "float", "for", "goto", "if", "implements", "import", 
	        "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", 
	        "public", "return", "short", "static", "strictfp", "super", "switch", "synchronized", "this", "throw", 
	        "throws", "transient", "try", "void", "volatile", "while"
		));
	
	private boolean isNotViableID(String id) {
		return javaKeyWords.contains(id);
	}
	
	@Check 
	void checkUserDeclarationID(UserDeclaration ud) {
		if (isNotViableID(ud.getName())) {
			error("No se puede emplear \"" + ud.getName() + "\" como un ID.", ud, null);
		}
	}
	
	@Check
	void checkChannelID(ChannelOperation co) {
		if (isNotViableID(co.getName())) {
			error("No se puede emplear \"" + co.getName() + "\" como un ID.", co, null);
		}
	}
	
	@Check
	public void checkUsersID(UserSection us) {
	    Set<String> users = new HashSet<>();
	    for (UserDeclaration userDeclaration : us.getUsers()) {
	        String currentID = userDeclaration.getName();
	        if (users.contains(currentID)) {
	            error("El nombre de usuario \"" + currentID + "\" ya está siento utilizado.", 
	            		userDeclaration, null);
	        } else {
	            users.add(currentID);
	        }
	    }
	}
	
	@Check
	public void checkChannelsID(ChannelSection cs) {
		Set<String> channels = new HashSet<>();
		for (ChannelOperation channelOperation : cs.getChannels()) {
			String currentChannelID = channelOperation.getName();
			if (channels.contains(currentChannelID)) {
				error("El nombre \"" + currentChannelID + "\" ya está siendo utilizado por otro canal.",
						channelOperation, null);
			} else {
				channels.add(currentChannelID);
			}
		}
	}
	
	@Check
	public void checkChannelUsage(Program p) {
		ChannelSection cns = p.getChannelSection();
		ChatSection cts = p.getExecution();
		Map<String, ChannelOperation> declaredChannels = new HashMap<>();
		for (ChannelOperation channelOperation : cns.getChannels()) {
			declaredChannels.put(channelOperation.getName(), channelOperation);
		}
		for (Instruction instruction: cts.getBody()) {
			if (instruction.getMode() instanceof ChannelCallImpl) {
				ChannelCall currentChannel = (ChannelCall)instruction.getMode();
				if (declaredChannels.containsKey(currentChannel.getName().getName())) {
					declaredChannels.remove(currentChannel.getName().getName());
				}
			}
		}
		for (Map.Entry<String, ChannelOperation> entry : declaredChannels.entrySet()) {
            String channelName = entry.getKey();
            ChannelOperation operation = entry.getValue();
            warning("El canal #" + channelName + " no está siendo utilizado.", operation, null);
        }
	}
	
	@Check
	public void checkChannelBody(ChannelOperation c) {
		if (c.getBody().size() == 0) {
			warning("El cuerpo del canal #" + c.getName() + " está vació.", c, null);
		}
	}
	
	
	public DataType getDataTypeFromExp(Expression e) {
		//Mi caso base son los literales y los llamados a variables
		DataType firstType = null;
		if (e.getSingleExpr() != null) {
			firstType = getDataTypeFromSingleExpression(e.getSingleExpr());
		} else if (e.getUserRef() != null) {
			firstType = e.getUserRef().getUser().getType();
		} else if (e.getParenthesisExpr() != null) {
			firstType = getDataTypeFromExp(e.getParenthesisExpr().getExpression());
		} else if (e.getSingleOpExpr() != null) {
			firstType = getDataTypeFromSingleOperator(e.getSingleOpExpr().getOperator());
		} 
		if (e.getSecond() != null) {
			DataType expressionType = validateTemporalExpression(firstType, e.getSecond());
			//Operación inválida lanza un null
			if (expressionType == null) {
				return null; 
			} else {
				return expressionType;
			}
		} else {
			return firstType;	
		}
	}
	
	public DataType getDataTypeFromExp(FollowExpression e) {
		//Mi caso base son los literales y los llamados a variables
		DataType firstType = null;
		if (e.getSingleExpr() != null) {
			firstType = getDataTypeFromSingleExpression(e.getSingleExpr());
		} else if (e.getUserRef() != null) {
			firstType = e.getUserRef().getUser().getType();
		} else if (e.getParenthesisExpr() != null) {
			firstType = getDataTypeFromExp(e.getParenthesisExpr().getExpression());
		} else if (e.getSingleOpExpr() != null) {
			firstType = getDataTypeFromSingleOperator(e.getSingleOpExpr().getOperator());
		} 
		return firstType;
	}
	
	public DataType getDataTypeFromSingleExpression(SingleExpression se) {
		EObject literal = se.getLiteral();
		if (literal instanceof IntLiteral) {
			return DataType.ENTERO_TYPE;
		} else if (literal instanceof DecLiteral){
			return DataType.DEC_TYPE;
		} else if (literal instanceof BoolLiteral) {
			return DataType.BOOL_TYPE;
		} else if (literal instanceof CadenasLiteral) {
			return DataType.CADENAS_TYPE;
		} else {
			return null;
		}
	}
	
	public DataType getDataTypeFromSingleOperator(SingleOperator operator) {
		if (operator == SingleOperator.BOOL_NEGATION) {
			return DataType.BOOL_TYPE ;
		} else if (operator == SingleOperator.INT_NEGATIVE || operator == SingleOperator.INT_PLUS_ONE) {
			return DataType.ENTERO_TYPE;
		} else {
			return null;
		}
	}
	
	public DataType validateTemporalExpression(DataType firstType, TempExpression second) {
		PairOperator operator = second.getOperador();
		DataType secondType = getDataTypeFromExp(second.getSecondValue());
		DataType expressionType = null;
		
		if (operator == PairOperator.PLUS|| operator == PairOperator.LESS|| operator == PairOperator.MULT|| operator == PairOperator.DIV) {
			if (firstType == DataType.ENTERO_TYPE && secondType == DataType.ENTERO_TYPE) expressionType = DataType.ENTERO_TYPE;
			if (firstType == DataType.ENTERO_TYPE && secondType == DataType.DEC_TYPE ||
				firstType == DataType.DEC_TYPE && secondType == DataType.ENTERO_TYPE ||
				firstType == DataType.DEC_TYPE  && secondType == DataType.DEC_TYPE ) expressionType = DataType.DEC_TYPE;
		} else if (operator == PairOperator.AND || operator == PairOperator.OR) {
			if(firstType == DataType.BOOL_TYPE && secondType == DataType.BOOL_TYPE) expressionType = DataType.BOOL_TYPE;
		} else if (operator == PairOperator.GREATER|| operator == PairOperator.GREATER_P||
				operator == PairOperator.GREATER_EQ|| operator == PairOperator.GREATER_EQ_P ) {
			if (firstType == DataType.ENTERO_TYPE && secondType == DataType.ENTERO_TYPE ||
				firstType == DataType.ENTERO_TYPE && secondType == DataType.DEC_TYPE ||
				firstType == DataType.DEC_TYPE && secondType == DataType.ENTERO_TYPE ||
				firstType == DataType.DEC_TYPE  && secondType == DataType.DEC_TYPE ) expressionType = DataType.BOOL_TYPE;
		} else if (operator == PairOperator.EQUAL || operator == PairOperator.EQUAL_P) {
			if (firstType == DataType.ENTERO_TYPE && secondType == DataType.ENTERO_TYPE ||
					firstType == DataType.ENTERO_TYPE && secondType == DataType.DEC_TYPE ||
					firstType == DataType.DEC_TYPE && secondType == DataType.ENTERO_TYPE ||
					firstType == DataType.DEC_TYPE  && secondType == DataType.DEC_TYPE ||
					firstType == DataType.BOOL_TYPE && secondType == DataType.BOOL_TYPE) expressionType = DataType.BOOL_TYPE;
		} else if (operator == PairOperator.CONCAT) {
			if (firstType == DataType.CADENAS_TYPE || secondType == DataType.CADENAS_TYPE) expressionType = DataType.CADENAS_TYPE;
		} else {
			return null;
		}
		
		if (second.getFollow() == null) {
			return expressionType;
		} else {
			return validateTemporalExpression(expressionType, second.getFollow());
		}
	}
	
	@Check
	public void checkAsignationDataType(UserAsignation ua) {
		DataType userType = ua.getUser().getType();
		Expression expr = ua.getValue();
		
		DataType exprType = getDataTypeFromExp(expr);
		if (exprType == null) {
			error ("Operaciones inválidas entre estos tipos de datos. " + 
					"Trate de operar con paréntesis o agregando nuevos usuarios intermedios.", ua, null);
		} else if (userType != exprType) {
			error("El usuario @" + ua.getUser().getName() + " forma parte de $" + userType + 
					", no de $" + exprType,
					ua, null);
		}
	}
	
	@Check
	public void checkSingleOperatorDataType(SingleOperatorExpression soe) {
		DataType expressionType = getDataTypeFromExp(soe.getExpression());
		SingleOperator operator = soe.getOperator();
		DataType operatorType = getDataTypeFromSingleOperator(operator);
		
		if (expressionType != operatorType) {
			error("La expresión pertenece a $" + expressionType + ", mientras que el operador pertence a $" + operatorType, soe, null);
		}
	}
	
}


