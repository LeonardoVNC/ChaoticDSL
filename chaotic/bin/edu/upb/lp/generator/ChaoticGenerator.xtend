/*
 * generated by Xtext 2.39.0
 */
package edu.upb.lp.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import edu.upb.lp.chaotic.Program
import edu.upb.lp.chaotic.UserSection
import edu.upb.lp.chaotic.ChannelSection
import edu.upb.lp.chaotic.ChatSection
import edu.upb.lp.chaotic.DataType
import edu.upb.lp.chaotic.UserAsignation
import edu.upb.lp.chaotic.PrintLine
import edu.upb.lp.chaotic.IfInstruction
import edu.upb.lp.chaotic.WhileInstruction
import edu.upb.lp.chaotic.ChannelCall
import edu.upb.lp.chaotic.BanException
import edu.upb.lp.chaotic.Instruction
import edu.upb.lp.chaotic.Expression
import edu.upb.lp.chaotic.SingleExpression
import edu.upb.lp.chaotic.SingleOperatorExpression
import edu.upb.lp.chaotic.UserDataReference
import edu.upb.lp.chaotic.ParenthesisExpression
import edu.upb.lp.chaotic.IntLiteral
import edu.upb.lp.chaotic.DecLiteral
import edu.upb.lp.chaotic.BoolLiteral
import edu.upb.lp.chaotic.CadenasLiteral
import edu.upb.lp.chaotic.SingleOperator
import edu.upb.lp.chaotic.FollowExpression
import edu.upb.lp.chaotic.TempExpression
import edu.upb.lp.chaotic.PairOperator
import edu.upb.lp.validation.ChaoticValidator
import edu.upb.lp.chaotic.ThreadSection
import edu.upb.lp.chaotic.ThreadAsignation
import edu.upb.lp.chaotic.ThreadDataReference

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
	
class ChaoticGenerator extends AbstractGenerator {
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.head as Program;
		fsa.generateFile(program.name+".java", generateProgram(program))
	}
	
	
	def nonForbiddenNameUser(String s) 
	'''«{idsSet.add(s) if (ChaoticValidator.javaKeyWords.contains(s)) "_"}»«s»'''
	
	def nonForbiddenNameThread(String s) 
	'''«{if (idsSet.contains(s)) s+"Thread" else if (ChaoticValidator.javaKeyWords.contains(s)) "_"+s else s}»'''
	
	def nonForbiddenNameChannel(String s) 
	'''«{idsSet.add(s) if (ChaoticValidator.javaKeyWords.contains(s)) "_"}»«s»'''
	
	
	def generateProgram(Program p) 
	'''
		public class «p.name» {
			«generateFields(p.userSection)»
						
			«generateThreads(p.threadSection)»
			
			«generateMethods(p.channelSection)»
			
			«generateMain(p.execution)»
		}
	'''
	
	
	def generateFields(UserSection us) 
	'''
	«
	us.users.map
	[userDeclaration | 
	"private static " + typeMap.get(userDeclaration.type ) + " " + nonForbiddenNameUser(userDeclaration.name)+";"]
	.join('\n')
	»
	'''
	
	def generateMethods(ChannelSection cs)
	'''
	«
	cs.getChannels.map
	[channelOperation | 
	"private static void " + nonForbiddenNameChannel(channelOperation.name) + "() throws Exception {\n"  + generateBody(channelOperation.body) + "}"].	
	join('\n')
	»
	'''
	
	
	def generateBody(Instruction[] body)
	'''
	«
	body.map
	[instruction | "\t" + generateInstruction(instruction.mode)].join('')
	»
	'''
	
	dispatch def generateInstruction(UserAsignation userAsignation)
	'''
		«nonForbiddenNameUser(userAsignation.user.name)» = «generateExpression(userAsignation.value)»;
	'''
	dispatch def generateInstruction(PrintLine print)
	'''
		System.out.println(«nonForbiddenNameUser(print.value.name)»);
	'''
	dispatch def generateInstruction(IfInstruction ifs)
	'''
		if («generateExpression(ifs.condition)») {
			«generateBody(ifs.body)»
		«"\t"»}
	'''
	dispatch def generateInstruction(WhileInstruction whiles)
	'''
		while («generateExpression(whiles.condition)») {
			«generateBody(whiles.body)»
		«"\t"»}
	'''
	dispatch def generateInstruction(ChannelCall channelCall)
	'''
		«nonForbiddenNameChannel(channelCall.name.name)»();
	'''
	dispatch def generateInstruction(BanException exception)
	'''
		throw new Exception(«if (exception.isDescription_flag) {"\"" + exception.description.value + "\""}»);
	'''
	dispatch def generateInstruction(ThreadAsignation threadAsign)
	'''
		«nonForbiddenNameThread(threadAsign.thread.name)»[«generateFollowExpression(threadAsign.pos)»] = «generateExpression(threadAsign.value)»;
	'''
	
	
	def generateThreads(ThreadSection ts)
	'''
		«if (ts.isThread_flag) { 
			ts.threads.map
			[threadDeclaration | "private static " + typeMap.get(threadDeclaration.type) + "[] " + nonForbiddenNameThread(threadDeclaration.name) + 
			" = new " + typeMap.get(threadDeclaration.type) + "[" + threadDeclaration.size.value + "];"].
			join('\n')
		} »
	'''

	
	def generateMain(ChatSection cs)
	'''
		public static void main(String[] args) throws Exception {
		«generateBody(cs.body)»
		}
	'''
	
	def generateExpression(Expression e) 
	'''«generateExpr(e.expr)»«generateTempExpression(e.second)»'''
		
	def generateSingleExpression(SingleExpression e) 
	'''«generateLiteralValue(e.literal)»'''
	
	def generateSingleOperatorExpression(SingleOperatorExpression e) 
	'''«if (e.operator == SingleOperator.BOOL_NEGATION) '!'+generateFollowExpression(e.expression)
		else if (e.operator == SingleOperator.INT_NEGATIVE) '-'+generateFollowExpression(e.expression)
		else if (e.operator == SingleOperator.INT_PLUS_ONE) generateFollowExpression(e.expression)+' + 1'  »'''
		
	def generateUserDataReference(UserDataReference e) 
	'''«nonForbiddenNameUser(e.user.name)»'''
	
	def generateParenthesisExpression(ParenthesisExpression e) 
	'''«'('+ generateExpression(e.expression) +')'»'''
	
	def generateThreadReference(ThreadDataReference e)
	'''«nonForbiddenNameThread(e.thread.name)»[«generateFollowExpression(e.pos)»]'''
	
	def generateFollowExpression(FollowExpression e)
	'''«generateExpr(e.expr)»'''
		
	
	def generateTempExpression(TempExpression e)
	'''«if (e === null) return ''
		else if (e.operador == PairOperator.PLUS)' + '
		else if (e.operador == PairOperator.LESS)' - '
		else if (e.operador == PairOperator.MULT)' * '
		else if (e.operador == PairOperator.DIV)' / '
		else if (e.operador == PairOperator.AND)' && '
		else if (e.operador == PairOperator.OR)' | |'
		else if (e.operador == PairOperator.EQUAL || e.operador == PairOperator.EQUAL_P)' == '
		else if (e.operador == PairOperator.GREATER || e.operador == PairOperator.GREATER_P)' > '
		else if (e.operador == PairOperator.GREATER_EQ || e.operador == PairOperator.GREATER_EQ_P)' >= '
		else if (e.operador == PairOperator.CONCAT)' + '»«generateFollowExpression(e.secondValue)»«generateTempExpression(e.follow)»'''

	dispatch def generateLiteralValue(IntLiteral i)'''«i.value»'''
	dispatch def generateLiteralValue(DecLiteral i)'''«i.mainValue + "." + i.decimalValue»'''
	dispatch def generateLiteralValue(BoolLiteral b)'''«b.value»'''
	dispatch def generateLiteralValue(CadenasLiteral s)'''"«s.value»"'''
	
	dispatch def generateExpr(SingleExpression e)'''«generateSingleExpression(e)»'''
	dispatch def generateExpr(SingleOperatorExpression e)'''«generateSingleOperatorExpression(e)»'''
	dispatch def generateExpr(UserDataReference e)'''«generateUserDataReference(e)»'''
	dispatch def generateExpr(ParenthesisExpression e)'''«generateParenthesisExpression(e)»'''
	dispatch def generateExpr(ThreadDataReference e)'''«generateThreadReference(e)»'''
	
	val typeMap = newHashMap(
		DataType.ENTERO_TYPE -> "int",
		DataType.DEC_TYPE -> "double",
		DataType.CADENAS_TYPE -> "String",
		DataType.BOOL_TYPE -> "Boolean"
	);
	
	val idsSet = newHashSet();
}
